Результаты и выводы

Я сюда скопировал все заметки, которые делал по ходу выполнения задания. По контексту должно быть понятно, к каким частям задания они относятся.

Реализовывать FastAPI я не стал, ибо это всё равно надо делать для курсового проекта, не представляется отдельно полезным. Это получается дублирование заданий в разных дисциплинах, восторга не вызывает никакого.

# По неизвестной мне причине, если я добавляю ещё одну ячейку ниже для удобного вывода, там ничего не выводится, хотя и считается. Поэтому здесь с принтом, хоть так и менее наглядно.
# Интересно, что колонки, для которых прописаны единицы измерения, вроде крутящего момента, не считаются числовыми (как раз из-за упоминания единиц измерения).
# Понравилось тренироваться с параметрами датафреймов (колонками, в частности).
# Получается, что всего 1159 строк, которые имеют двойника. В документации написано, что первая встречающаяся строка не считается дубликатом себя, так что это число должно быть верным.
# Для начала надо понять названия столбцов, по которым будем искать дубликаты. Это должны быть все столбцы, кроме столбца с ценой.
# Получим их список:
# Видимо, далее будем исходить из того, что признак torque разделён на два столбца.
# Выбираю подход "используем регулярные выражения для отсекания ненужного из строки". А для max_torque_rpm надо будет посмотреть, в каких форматах там пишется.
# Добавил в блок импортирования модулей import re
# У нас есть переменная train_columns_with_misses. Сейчас пригодится.
# Update: Она была хороша, пока мы не добавили новую колонку. Теперь переменную надо пересчитать. А она ещё зависела от колонок вообще, их тоже надо пересчитать.
# Из наблюдения за данными видно, что с ценой продажи хорошо коррелирует мощность (max_power), и, по-видимому, связанные с мощностью же engine и torque.
# Кажется, что корреляции упомянутых engine, max_power и torque с ценой здесь тоже хорошо видны.
# Хуже всего скоррелированы mileage и engine.
# Сильная положительная линейная зависимость видна между engine/seats, max_power/torque, engine/max_power.
# Касательно года и пройденных километров -- вроде бы да. Это логично, ведь меньший год означает больший возраст автомобиля, и за эти годы можно проехать больше.
# Мне кажутся ещё важными зависимости engine/torque, max_power/torque. Давайте их выведу.
# Почему мне кажется, что они важны? Раз они так хорошо коррелируют, и являются по сути параметрами двигателя, может, какие-то из них можно выбросить без особой потери, и модель будет проще.
# Я не понимаю, почему почти нет разницы в R2. В лекции вон как наглядно было.
# Это, я так понимаю, надо посмотреть на то, где самые большие по модулю веса. Вроде бы должно быть что-то с мощностью связано. Проверим это.
# Выглядит так, что это max_power, и ещё и seats.
# Выглядит, что нет. Наоборот, они какие-то здоровенные. С другой стороны, цена ведь тоже не три рубля. Да и w0 вон тоже не маленький. Почему не зануляют? Наверное, все они важны для определения цены, как-то влияют и пробег, и мощность, и число сидений.
# А ещё из анализа весов видно, что пройденные километры сокращают цену (т.к. знак минус при весе). А почему максимальные обороты сокращают тоже? Это я не понимаю. Зато хорошо видно, что max_power является определяющим факторов.
# В эксперименте на 150 вариантов alpha результат практически не отличается. И ничего не занулилось. Поэтому вернулся назад к 14 вариантам.
# Обучилось, видимо, 140 моделей -- на каждый из вариантов alpha по 10 сборок выборок.
# alpha = 14, l1_ratio = 1
# Но они тоже практически не меняют результат (пятый-шестой знак после запятой -- это не изменение). В чате другие участники вроде бы то же самое отмечали.
# Опытным путём ниже было установлено, что seats содержит меньше вариантов действий для тестовой выборки, чем для тренировочной. Поскольку я ещё не научился обрабатывать ситуации, когда выборки существенно различаются, на всякий случай буду считать seats как числовой признак. (Да, это плохо, но лучше, чем стоять и тратить ещё время.)
# Я это сделал после того, как всё раскатегоризировал, так что это у меня получилось.
# Или надо сначала нормализовывать, а потом категории оцифровывать? Вроде бы должно быть лучше так, как я сделал.
# Ура, в эксперименте получилось число, отлично от максимально возможного (300!) И это число 32.
# Правда, результаты недалеко ушли от таковых для параметров по умолчанию.
# Лучше всего у меня получилось с ridge, так что возьмём его. Я так понимаю, что надо тестовую выборку брать, ведь на ней более реальная ситуация показывается.

